{"version":3,"sources":["C:/Angular/AlphaPro/node_modules/ngx-image-compress/fesm2015/ngx-image-compress.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4RC,oIAGC;;;;;;;iFAIA","file":"ngx-image-compress.js","sourcesContent":["import { Injectable, RendererFactory2 } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst DOC_ORIENTATION = {\n    Up: 1,\n    Down: 3,\n    Right: 6,\n    Left: 8,\n    UpMirrored: 2,\n    DownMirrored: 4,\n    LeftMirrored: 5,\n    RightMirrored: 7,\n    NotJpeg: -1,\n    NotDefined: -2,\n};\nDOC_ORIENTATION[DOC_ORIENTATION.Up] = 'Up';\nDOC_ORIENTATION[DOC_ORIENTATION.Down] = 'Down';\nDOC_ORIENTATION[DOC_ORIENTATION.Right] = 'Right';\nDOC_ORIENTATION[DOC_ORIENTATION.Left] = 'Left';\nDOC_ORIENTATION[DOC_ORIENTATION.UpMirrored] = 'UpMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.DownMirrored] = 'DownMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.LeftMirrored] = 'LeftMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.RightMirrored] = 'RightMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.NotJpeg] = 'NotJpeg';\nDOC_ORIENTATION[DOC_ORIENTATION.NotDefined] = 'NotDefined';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ImageCompress {\n    /**\n     * Get the correct Orientation value from tags, in order to write correctly in our canvas\n     * @param {?} file\n     * @param {?} callback\n     * @return {?}\n     */\n    static getOrientation(file, callback) {\n        /** @type {?} */\n        const reader = new FileReader();\n        try {\n            reader.onload = (/**\n             * @param {?} $event\n             * @return {?}\n             */\n            function ($event) {\n                /** @type {?} */\n                const view = new DataView((/** @type {?} */ (reader.result)));\n                if (view.getUint16(0, false) !== 0xFFD8) {\n                    return callback(-2);\n                }\n                /** @type {?} */\n                const length = view.byteLength;\n                /** @type {?} */\n                let offset = 2;\n                while (offset < length) {\n                    /** @type {?} */\n                    const marker = view.getUint16(offset, false);\n                    offset += 2;\n                    if (marker === 0xFFE1) {\n                        if (view.getUint32(offset += 2, false) !== 0x45786966) {\n                            return callback(-1);\n                        }\n                        /** @type {?} */\n                        const little = view.getUint16(offset += 6, false) === 0x4949;\n                        offset += view.getUint32(offset + 4, little);\n                        /** @type {?} */\n                        const tags = view.getUint16(offset, little);\n                        offset += 2;\n                        for (let i = 0; i < tags; i++) {\n                            if (view.getUint16(offset + (i * 12), little) === 0x0112) {\n                                return callback(view.getUint16(offset + (i * 12) + 8, little));\n                            }\n                        }\n                    }\n                    else if ((marker & 0xFF00) !== 0xFF00) {\n                        break;\n                    }\n                    else {\n                        offset += view.getUint16(offset, false);\n                    }\n                }\n                return callback(-1);\n            });\n            reader.readAsArrayBuffer(file);\n        }\n        catch (e) {\n            return callback(0);\n        }\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * @param {?} render\n     * @return {?}\n     */\n    static uploadFile(render) {\n        /** @type {?} */\n        const promise = new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        function (resolve, reject) {\n            /** @type {?} */\n            const inputElement = render.createElement('input');\n            render.setStyle(inputElement, 'display', 'none');\n            render.setProperty(inputElement, 'type', 'file');\n            render.setProperty(inputElement, 'accept', 'image/*');\n            render.listen(inputElement, 'click', (/**\n             * @param {?} $event\n             * @return {?}\n             */\n            ($event) => {\n                //console.log('MouseEvent:', $event);\n                //console.log('Input:', $event.target);\n                $event.target.value = null;\n            }));\n            render.listen(inputElement, 'change', (/**\n             * @param {?} $event\n             * @return {?}\n             */\n            ($event) => {\n                /** @type {?} */\n                const file = $event.target.files[0];\n                /** @type {?} */\n                const myReader = new FileReader();\n                myReader.onloadend = (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => {\n                    try {\n                        ImageCompress.getOrientation(file, (/**\n                         * @param {?} orientation\n                         * @return {?}\n                         */\n                        orientation => {\n                            resolve({ image: (/** @type {?} */ (myReader.result)), orientation });\n                        }));\n                    }\n                    catch (e) {\n                        //console.log(`ngx-image-compress error ${e}`);\n                        reject(e);\n                    }\n                });\n                try {\n                    myReader.readAsDataURL(file);\n                }\n                catch (e) {\n                    console.warn(`ngx-image-compress - probably no file have been selected: ${e}`);\n                    reject(\"No file selected\");\n                }\n            }));\n            inputElement.click();\n        }));\n        return promise;\n    }\n    /**\n     * @param {?} imageDataUrlSource\n     * @param {?} orientation\n     * @param {?} render\n     * @param {?=} ratio\n     * @param {?=} quality\n     * @return {?}\n     */\n    static compress(imageDataUrlSource, orientation, render, ratio = 50, quality = 50) {\n        /** @type {?} */\n        const promise = new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        function (resolve, reject) {\n            quality = quality / 100;\n            ratio = ratio / 100;\n            /** @type {?} */\n            const sourceImage = new Image();\n            // important for safari: we need to wait for onload event\n            sourceImage.onload = (/**\n             * @return {?}\n             */\n            function () {\n                /** @type {?} */\n                const canvas = render.createElement('canvas');\n                /** @type {?} */\n                const ctx = canvas.getContext('2d');\n                /** @type {?} */\n                let w;\n                /** @type {?} */\n                let h;\n                w = sourceImage.naturalWidth;\n                h = sourceImage.naturalHeight;\n                if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n                    /** @type {?} */\n                    const t = w;\n                    w = h;\n                    h = t;\n                }\n                canvas.width = w * ratio;\n                canvas.height = h * ratio;\n                /** @type {?} */\n                const TO_RADIANS = Math.PI / 180;\n                if (orientation === DOC_ORIENTATION.Up) {\n                    ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n                }\n                else if (orientation === DOC_ORIENTATION.Right) {\n                    ctx.save();\n                    ctx.rotate(90 * TO_RADIANS);\n                    ctx.translate(0, -canvas.width);\n                    ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n                    ctx.restore();\n                }\n                else if (orientation === DOC_ORIENTATION.Left) {\n                    ctx.save();\n                    ctx.rotate(-90 * TO_RADIANS);\n                    ctx.translate(-canvas.width, 0);\n                    ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n                    ctx.restore();\n                }\n                else if (orientation === DOC_ORIENTATION.Down) {\n                    ctx.save();\n                    ctx.rotate(180 * TO_RADIANS);\n                    ctx.translate(-canvas.width, -canvas.height);\n                    ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n                    ctx.restore();\n                }\n                else {\n                    //console.warn('ngx-image-compress - no orientation value found');\n                    // same as default UP\n                    ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n                }\n                /** @type {?} */\n                const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n                // TODO test on mime\n                /** @type {?} */\n                const result = canvas.toDataURL(mime, quality);\n                resolve(result);\n            });\n            sourceImage.src = imageDataUrlSource;\n        }));\n        return promise;\n    }\n    /**\n     * helper to evaluate the compression rate\n     * @param {?} s the image in base64 string format\n     * @return {?}\n     */\n    static byteCount(s) {\n        return encodeURI(s).split(/%..|./).length - 1;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass NgxImageCompressService {\n    /**\n     * @param {?} rendererFactory\n     */\n    constructor(rendererFactory) {\n        this.DOC_ORIENTATION = DOC_ORIENTATION;\n        this.render = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * @param {?} image\n     * @return {?}\n     */\n    byteCount(image) {\n        return ImageCompress.byteCount(image);\n    }\n    /**\n     * @return {?}\n     */\n    uploadFile() {\n        return ImageCompress.uploadFile(this.render);\n    }\n    /**\n     * @param {?} image\n     * @param {?} orientation\n     * @param {?=} ratio\n     * @param {?=} quality\n     * @return {?}\n     */\n    compressFile(image, orientation, ratio = 50, quality = 50) {\n        return ImageCompress.compress(image, orientation, this.render, ratio, quality);\n    }\n}\nNgxImageCompressService.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nNgxImageCompressService.ctorParameters = () => [\n    { type: RendererFactory2 }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    NgxImageCompressService.prototype.render;\n    /** @type {?} */\n    NgxImageCompressService.prototype.DOC_ORIENTATION;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DOC_ORIENTATION, NgxImageCompressService };\n"]}